#version 450 core

layout(triangles, equal_spacing, ccw) in;

vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2) ;
vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2) ;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform vec3 viewPos;
uniform float time;
uniform float DENS;
uniform float G;

in vec3 posTC[] ;
in vec2 texCoordsTC[];

out vec3 posES ;
out vec2 TexCoordsES;
out float visibilityES;

struct Wave
{
	float amp;
	vec2 waveDir;
	float crestdist;
	float speed;
};

#define numWaves 1
uniform Wave waves[numWaves];

vec3 CalcGerstnerWaves(vec3 V, float amp, vec2 wavedir, float crestdist, float speed);

void main()
{

   posES = interpolate3D(posTC[0], posTC[1], posTC[2]) ;
   TexCoordsES = interpolate2D(texCoordsTC[0], texCoordsTC[1], texCoordsTC[2]) ;
	vec3 positionModification = vec3(0.0f);
	for(int i = 0; i < numWaves; i++)
	{
		positionModification += CalcGerstnerWaves(posES, waves[i].amp, waves[i].waveDir, waves[i].crestdist, waves[i].speed);
	}
	
	//positionModification = normalize(positionModification);
   //vec3 positionModification = CalcGerstnerWaves(posES, 1.5, vec2(1.0,0.0),50,0.5);
   
   gl_Position = projection * view * vec4(positionModification, 1.0); 

   //fog stuff
	float distanceFromCamera = distance(viewPos, posES);
	visibilityES = exp(-pow((distanceFromCamera*DENS),G));
	visibilityES = clamp(visibilityES, 0.0, 1.0);
} 


//basic linear interpolation
vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2)
{
       return vec2(gl_TessCoord.x) * v0 + vec2(gl_TessCoord.y) * v1 + vec2(gl_TessCoord.z) * v2;
}

vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2)
{
       return vec3(gl_TessCoord.x) * v0 + vec3(gl_TessCoord.y) * v1 + vec3(gl_TessCoord.z) * v2;
}

vec3 CalcGerstnerWaves(vec3 V, float amp, vec2 wavedir, float crestdist, float speed){
    speed*=time;
    float wavelength = (2*3.14152)/crestdist;
    float phasespd = sqrt(9.8)/wavelength; //phase speed

    float f = V.y+(dot(V.xy,wavedir)-phasespd*speed)*wavelength;
    V.x += wavedir.x*(amp*cos(f));
    V.y += amp*sin(f);
    V.z += wavedir.y*(amp*cos(f));

    return V;
}